# Knapsack-Public-key-Cryptosystem
â€¢  Coded an algorithm in MATLAB devised to Encrypt message text into cipher text and successfully transmit the Decrypted message using weighted encryption key generated by modular arithmetic operations done on the Private key and successfully applied this concept to images.

READ ME



The code takes a lot of time to execute because of the calculations and the size of the image so, first run the trial3.m program where there is a smaller image chosen for the program.

Lena is used in the Imagefinal.m program and it takes time to process.
 
The decryption is tough and hence it might take a few minutes to get the output image, thus after running the code please wait till the code executes or check it after a few minutes.

Depending on the size of the image the encryption can take few minutes andd decryption can take about an hour so please run the trial3.m file first. It is the same code. Just a smaller image(48x48) while lena is 512X512


The functions used are similar to the ones used for the message encryption code
The code isn't robust yet because it doesnt have conditions to break execution if wrong inputs are given. It does however check for valid inputs.

The Decryption process takes longer than the encryption.

The image and the codes should be in the same address or folder

-> Image is chosen

-> It is converted from rgb to gray scale

-> We use the reshape funcction to get all the intensities into a single array which is our message signal

-> The values in the image are converted to string of binary numbers. They all lie between 0-255. Hence 8 bits

-> We then input two knapsack arrays of eight elements one for the odd row and one for even row

-> Then need to be super increasing and the prime generator and modulo must be chosen seperately for the odd and even rows

-> Issuperinc() and pgmodcheck() are user defined functions that check the validity. However if it isnt valid it doesnt stop execution. That is why it isnt robust yet. I shall include the break points later. This is currently to check if the programm works

-> For Trial run, i have chosen the we and wo to be same . It works perfectly
   Eg: we=wo=[1,2,4,10,20,40,80,170]
       pe=po= 31
       xe=xo= 458
The values of odd and even parameters can be different.
-> we and wo must be super increasing as per the knapsack algorithm
pe and po are prime numbers and they should be co primes with xe and xo
-> Keep in mind that the value of xe or xo must be greater than the sum of the elements in the super increassing sequence that is our private key we or wo.

-> By using reshape the we turn the matrix into a single array
 
-> So this code is tantamount to using a seperate key for each column as asked

-> after encryption using public keys the decryption is done an then the values are coverted to binary factors of the keys and then they are turned to intergers in the range of 0-255

-> final Encrypted image is displayed after using reshape to convert the array to a matrix


The output is a gray scale image
It can be converted to rgb using following methods


.........To convert a uint8 or double grayscale image to an RGB image of the same data 	type, you can use the functions REPMAT or CAT:
	 rgbImage = repmat(grayImage,[1 1 3]);
         rgbImage = cat(3,grayImage,grayImage,grayImage);

...........To convert a uint8 grayscale image to a double RGB image, you should convert            to double first, then scale by 255:

           rgbImage = repmat(double(grayImage)./255,[1 1 3]);
	
...........To convert a double grayscale image to a uint8 RGB image, you should scale by 	  255 first, then convert to uint8:
	
            rgbImage = repmat(uint8(255.*grayImage),[1 1 3]);

This hasnt been included in the code due to time constraints
but it can be implemented easily. I shall put this in the modified code.


Currently this program is to show the cryptanalysis of the image using Knapsack-type Public key encryption 
